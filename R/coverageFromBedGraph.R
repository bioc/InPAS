#' Read coverage from bedGraph files
#' 
#' Read in read coverage from bedGraph files and store it as a list
#'
#' @param bedgraphs The file names of bedgraphs generated by bedtools. 
#'  eg: bedtools genomecov-bg -split -ibam $bam > $bedgraph
#' @param tags Name tags used to label each input bedgraph
#' @param genome An object of [BSgenome::BSgenome-class]
#' @param removeScaffolds logical(1), whether the scaffolds should be 
#' removed from the genome
#' @param hugeData logical(1). Is this dataset consume too much memory? 
#'  if it is TRUE, the coverage will be saved into tempfiles.
#' @param BPPARAM an optional [BiocParallel::BiocParallelParam-class] 
#' instance determining the parallel back-end to be used during evaluation, 
#' or a list of BiocParallelParam instances, to be applied in sequence for
#' nested calls to bplapply
#' @param ... Parameters can be passed into the tempfile() function. This is 
#'  useful when you submit hugedataset to cluster.
#'
#' @return  A list of read coverage for each bedgraph file. For each item 
#'  in the list, it is a list of coverage for each chromosome. And the 
#'  chromosome must start with "chr".
#' @export
#' @import BiocParallel 
#' @import readr
#'
#' @examples 
#' if(interactive()) {
#' library(BSgenome.Mmusculus.UCSC.mm10)
#' path <- file.path(find.package("InPAS"), "extdata")
#' bedgraphs <- file.path(path, "Baf3.extract.bedgraph")
#' data(utr3.mm10)
#' tags <- "Baf3"
#' genome <- BSgenome.Mmusculus.UCSC.mm10
#' coverage <- coverageFromBedGraph(bedgraphs, tags, 
#' genome, hugeData = FALSE)
#' }
#' 
#' 
coverageFromBedGraph <- function(bedgraphs, tags, 
                                 genome,
                                 removeScaffolds = FALSE,
                                 hugeData=FALSE, 
                                 BPPARAM=NULL, ...){
    if(missing(genome))
        stop("genome is required.")
    if(!is(genome, "BSgenome"))
        stop("genome must be an object of BSgenome.")
    if(missing(tags) || missing(bedgraphs))
        stop("tags and bedgraphs are required.")
    if(length(tags)!= length(bedgraphs)){
        stop("length of tags and bedgraphs should be identical")
    }
    if(!is.character(tags))
        stop("tags must be a character vector")
    if(any(duplicated(tags)))
        stop("tags must be unique")
    if(any(!file.exists(bedgraphs)))
        stop("Not all bedgraphs exist")
    
    ## check the bedgraphs, can not be empty.
    null <- sapply(bedgraphs, function(.ele){
        read_tsv(.ele, 
                 col_names = FALSE, 
                 comment = "#", 
                 n_max = 5,
                 col_types =cols(
                     X1 = col_skip(),
                     X2 = col_integer(),
                     X3 = col_integer(),
                     X4 = col_integer()))
    })
    
    seqLen <- seqLen(genome, removeScaffolds)
    ## get coverage for all inputs
    names(bedgraphs) <- tags
    x <- 1:length(bedgraphs)
    
    ## split into multigroup, 10 bedgraphs files per group 
    y <- split(x, ceiling(x/10))
    
    ## huge data processing mode
    if(hugeData){
        coverage <- bedgraphs
        ## BiocParallel processing per group of bedgraph files
        for(i in 1:length(y)){
            if(!is.null(BPPARAM)){
                cv <- bptry(bplapply(bedgraphs[y[[i]]], 
                        function(.ele){
                            cvg <- getCov(.ele, genome, 
                                          seqLen, 
                                          removeScaffolds = removeScaffolds)
                            filename <- tempfile(...)
                            save(list = "cvg", file = filename)
                            filename}, BPPARAM = BPPARAM))

                ## if any parallel process goes wrong, redo it only
                while(!all(bpok(cv))){
                    cv <- bptry(bplapply(bedgraphs[y[[i]]], 
                                function(.ele){
                                cvg <- getCov(.ele, genome, 
                                              seqLen, 
                                    removeScaffolds = removeScaffolds)
                                filename <- tempfile(...)
                                save(list="cvg", file=filename)
                                filename
                        }, BPREDO=cv, BPPARAM=BPPARAM))
                    }
            } else {   ## This might not be necessary for hugeData
                       cv <- lapply(bedgraphs[y[[i]]], 
                                    function(.ele){
                       cvg <- getCov(.ele, genome, 
                                     seqLen, 
                                     removeScaffolds = removeScaffolds)
                       filename <- tempfile(...)
                       save(list="cvg", file=filename)
                       filename})
                   }
            coverage[names(cv)] <- unlist(cv)
        }
        coverage <- as.list(coverage[tags])
    } else {  
        ## for a small set of bedgraph files, the coverage 
        ## as a list of Rle object per seqname is returned
        
        coverage <- list()
        # predefine an empty list of specific length
        # coverage <- vector(mode = "list", length = length(y))
        
        ## here y and i are not used? 
        ## Haibo removed  the for loop: for(i in 1:length(y)) here
        if(!is.null(BPPARAM)){
            cv <- bplapply(bedgraphs, getCov, 
                           genome = genome, 
                           seqLen = seqLen,
                           removeScaffolds = removeScaffolds,
                           BPPARAM = BPPARAM)
            } else {
            cv <- lapply(bedgraphs, getCov,
                         genome = genome, 
                         seqLen = seqLen,
                         removeScaffolds = removeScaffolds)
            }
        coverage <- c(coverage, cv) ## flatten out nested list
        coverage <- coverage[tags]  ## reorder coverage list according to tags
    }
    coverage
}