% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/03.get_ssRleCov.R, R/04.get_ssRleCov.R
\name{get_ssRleCov}
\alias{get_ssRleCov}
\title{Get Rle coverage from a bedgraph file for a sample}
\usage{
get_ssRleCov(
  bedgraph,
  tag,
  genome,
  sqlite_db,
  outdir,
  BATCH_SIZE = 10L,
  removeScaffolds = FALSE,
  BPPARAM = NULL
)

get_ssRleCov(
  bedgraph,
  tag,
  genome,
  sqlite_db,
  outdir,
  BATCH_SIZE = 10L,
  removeScaffolds = FALSE,
  BPPARAM = NULL
)
}
\arguments{
\item{bedgraph}{A path to a bedGraph file}

\item{tag}{A character(1) vector, a name tag used to label the bedgraph file.
It must match the tag specified in the metadata file used to setup the
SQLite database}

\item{genome}{an object \link[BSgenome:BSgenome-class]{BSgenome::BSgenome}. To make things easy, we
suggest users creating a \link[BSgenome:BSgenome-class]{BSgenome::BSgenome} instance from the
reference genome used for read alignment. For details, see the
documentation of \code{\link[BSgenome:BSgenomeForge]{BSgenome::forgeBSgenomeDataPkg()}}.}

\item{sqlite_db}{A path to the SQLite database for InPAS, i.e. the output of
\code{\link[=setup_sqlitedb]{setup_sqlitedb()}}.}

\item{outdir}{A character(1) vector, a path with write permission for storing
the coverage data. If it doesn't exist, it will be created.}

\item{BATCH_SIZE}{A integer(1) vector, indicating the number of parallel jobs
run at the same time per batch. Default, 10. You may adjust this number
based based on the available computing resource: CPUs and RAM. For
BATCH_SIZE of 10, 15-20G RAM is needed. This parameter affects the time for
converting coverage from bedgraph to Rle.}

\item{removeScaffolds}{A logical(1) vector, whether the scaffolds should be
removed from the genome If you use a TxDb containing alternative
scaffolds, you'd better to remove the scaffolds.}

\item{BPPARAM}{an optional \link[BiocParallel:BiocParallelParam-class]{BiocParallel::BiocParallelParam} instance
determining the parallel back-end to be used during evaluation, or a list
of BiocParallelParam instances, to be applied in sequence for nested calls
to bplapply. It can be set to NULL or bpparam()}

\item{future.chunk.size}{The average number of elements per future
("chunk"). If Inf, then all elements are processed in a single future.
If NULL, then argument future.scheduling = 1 is used by default. Users can
set future.chunk.size = total number of elements/number of cores set for
the backend. See the future.apply package for details. You may adjust
this number based based on the available computing resource: CPUs and RAM.
This parameter affects the time for converting coverage from bedgraph to Rle.}

\item{chr2exclude}{A character vector, NA or NULL, specifying chromosomes or
scaffolds to be excluded for InPAS analysis. \code{chrM} and alternative scaffolds
representing different haplotypes should be excluded.}
}
\value{
A data frame, as described below.
\describe{
\item{tag}{the sample tag}
\item{chr}{chromosome name}
\item{coverage_file}{path to Rle coverage files for each chromosome
per sample tag}
}

A list of lists containing read coverage as Rle instances of
\link[S4Vectors:Rle-class]{S4Vectors::Rle} representing read coverage for each chromosome of
a given sample, as described below.
\describe{
\item{tag}{the sample tag}
\describe{
\item{chr1}{coverage as Rle instance for chr1}
\item{chr2}{coverage as Rle instance for chr2}
\item{chrN}{coverage as Rle instance for chrN}
}
}
}
\description{
Get RLe coverage from a bedgraph file for a sample

Get RLe coverage from a bedgraph file for a sample
}
\examples{
if (interactive()) {
  library(BSgenome.Mmusculus.UCSC.mm10)
  genome <- BSgenome.Mmusculus.UCSC.mm10
  bedgraphs <- system.file("extdata", c(
    "Baf3.extract.bedgraph",
    "UM15.extract.bedgraph"
  ),
  package = "InPAS"
  )
  tags <- c("Baf3", "UM15")
  metadata <- data.frame(
    tag = tags,
    condition = c("Baf3", "UM15"),
    bedgraph_file = bedgraphs
  )
  outdir <- tempdir()
  write.table(metadata,
    file = file.path(outdir, "metadata.txt"),
    sep = "\t", quote = FALSE, row.names = FALSE
  )

  sqlite_db <- setup_sqlitedb(
    metadata = file.path(
      outdir,
      "metadata.txt"
    ),
    outdir
  )
  addLockName()
  coverage_info <- get_ssRleCov(
    bedgraph = bedgraphs[1],
    tag = tags[1],
    genome = genome,
    sqlite_db = sqlite_db,
    outdir = outdir,
    chr2exclude = "chrM"
  )
  # check read coverage depth
  db_connect <- dbConnect(drv = RSQLite::SQLite(), dbname = sqlite_db)
  dbReadTable(db_connect, "metadata")
  dbDisconnect(db_connect)
}
if (interactive()) {
   library(BSgenome.Mmusculus.UCSC.mm10)
   genome <- BSgenome.Mmusculus.UCSC.mm10
   bedgraphs <- system.file("extdata",c("Baf3.extract.bedgraph",
                                        "UM15.extract.bedgraph"), 
                           package = "InPAS")
   tags <- c("Baf3", "UM15")
   metadata <- data.frame(tag = tags, 
                          condition = c("Baf3", "UM15"),
                          bedgraph_file = bedgraphs)
   outdir = tempdir()
   write.table(metadata, file =file.path(outdir, "metadata.txt"), 
               sep = "\t", quote = FALSE, row.names = FALSE)
   
   sqlite_db <- setup_sqlitedb(metadata = file.path(outdir, 
                                                    "metadata.txt"),
                               outdir)
   coverage <- get_ssRleCov(bedgraph = bedgraphs[1], 
                          tag = tags[1],
                          genome = genome,
                          sqlite_db = sqlite_db,
                          outdir = outdir,
                          removeScaffolds = TRUE,
                          BPPARAM = NULL)
   # check read coverage depth
   db_connect <- dbConnect(drv = RSQLite::SQLite(), dbname = sqlite_db)
   dbReadTable(db_connect, "metadata")
   dbDisconnect(db_connect)
}
}
\author{
Jianhong Ou, Haibo Liu

Jianhong Ou, Haibo Liu
}
