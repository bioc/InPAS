---
title: "InPAS Vignette"
author: "Jianhong Ou, Sungmi Park, Michael Green, Lihua Julie Zhu"
date: "`r doc_date()`"
package: "`r pkg_ver('InPAS')`"
bibliography: ref.bib
csl: nature.csl
abstract: >
   Alternative polyadenylation (APA) is one of the important post-transcriptional
   regulation mechanisms which occurs in most human genes. InPAS facilitates the 
   discovery of novel APA sites and the differential usage of APA sites from 
   RNA-Seq data. It leverages cleanUpdTSeq[@sheppard2013accurate] to fine tune
   identified APA sites by removing false sites due to internal-priming.
vignette: >
  %\VignetteIndexEntry{InPAS Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document
---
```{r preloadLibrary, echo=FALSE, results="hide", warning=FALSE}
suppressPackageStartupMessages({
    library(InPAS)
    library(BSgenome.Mmusculus.UCSC.mm10)
    library(TxDb.Mmusculus.UCSC.mm10.knownGene)
    library(EnsDb.Hsapiens.v86)
    library(EnsDb.Mmusculus.v79)
    library(cleanUpdTSeq)
})
```
# Introduction

Alternative polyadenylation (APA) is one of the most important 
post-transcriptional regulation mechanisms which is prevalent in Eukaryotas. Like alternative splicing, APA can increase transcriptome diversity. 
In addition, it defines 3' UTR and results in altered expression of the gene.
It is a tightly controlled process and mis-regulation of APA can affect many biological processed, such as uncontrolled cell cycle and growth. 
Although several high throughput sequencing methods have been developed, 
there are still limited data dedicated to identifying APA events.

However, massive RNA-seq datasets, which were originally created to quantify
genome-wide gene expression, are available in public databases such as GEO and TCGA. These RNA-seq datasets also contain information of genome-wide APA. Thus, we developed the InPAS algorithm for identifying APA from the conventional RNA-seq data.

The workflow for InPAS is:

- Calculate genome-wide read coverage per sample from individual BEDGraph files  
- Identify putative polyadenylation (pA) sites for each gene based on the read coverage fluctuation  
- Filter putative pA sites using the cleanUpdTseq function to remove potential false pA sites due to oligo-dT-mediated internal priming (depends on the library construction protocol, not always necessary).  
- Estimate alternative pA usage using the read coverage along the predicted 3' UTRs
- Identify differential usage of APA between different conditions leveraging the limma package (Does read coverage approximately follows a normal distribution?) 

# How to

First, load the required libraries InPAS, species specific BSgenome, and TxDb as follows.

```{r loadLibrary}
library(InPAS)
library(BSgenome.Mmusculus.UCSC.mm10)
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
```

Next, extract 3' annotation using the function `utr3Annotation` from genome annotation databases: a TxDb database and an Ensembldb annotation for a species of interest.
Please note that the 3' UTR annotation prepared by `utr3Annotation` 
includes the gaps to the next downstream exon.

```{r prepareAnno}
library(EnsDb.Hsapiens.v86)
samplefile <- system.file("extdata", 
                          "hg19_knownGene_sample.sqlite",
            package="GenomicFeatures")
txdb <- loadDb(samplefile)
utr3.sample.anno <- 
  utr3Annotation(TxDb = txdb,
                 edb = EnsDb.Hsapiens.v86,
                 removeScaffolds = TRUE)
utr3.sample.anno
```

Users can also directly load the 3' UTR annotation included in this package 
for mm10 and hg19. Here we show how to load the pre-built mm10 3' UTR annotation file.

```{r loadAnno}
##step1 annotation
# load from dataset
data(utr3.mm10)
```

For coverage calculation, alignment files in BEDGraph format are required, 
which can be generated from BAM files using the genomecov tool in bedtools
with parameter: -bg -split. Potential pA sites identified from the coverage
data can be filtered/adjusted using the classifier provided by _cleanUpdTseq_. 
The following scripts illustrate the function calls needed to perform the 
complete analysis using _InPAS_.

```{r step2HugeDataF}
data_dir <- system.file("extdata", package = "InPAS")
data(polyA)
library(cleanUpdTSeq)
data(classifier)
bedgraphs <- c(file.path(data_dir, "Baf3.extract.bedgraph"), 
               file.path(data_dir, "UM15.extract.bedgraph"))
hugeData <- FALSE
##step1 Calculate coverage
coverage <- coverageFromBedGraph(bedgraphs, 
                                 tags=c("Baf3", "UM15"),
                                 genome=BSgenome.Mmusculus.UCSC.mm10,
                                 removeScaffolds = TRUE,                               
                                 hugeData = hugeData)

## we hope the coverage rate of should be greater than 0.75 in the expressed gene.
## which is used because the demo data is a subset of genome.
library("EnsDb.Mmusculus.v79")
edb <- EnsDb.Mmusculus.v79
coverageRate(
  coverage = coverage,
  edb = edb,
  TxDb = TxDb.Mmusculus.UCSC.mm10.knownGene,
  genome = BSgenome.Mmusculus.UCSC.mm10,
  removeScaffolds = TRUE,
  which = GRanges("chr6",
                  ranges = IRanges(98013000, 140678000)))

##step2 Predict cleavage sites
CPs <- CPsites(coverage=coverage, 
               genome=BSgenome.Mmusculus.UCSC.mm10,
               utr3=utr3.mm10, 
               search_point_START=200, 
               cutEnd=.2, 
               long_coverage_threshold=3,
               background="10K",
               txdb=TxDb.Mmusculus.UCSC.mm10.knownGene,
               PolyA_PWM=pwm, 
               classifier=classifier,
               shift_range=50,
               step=10)
head(CPs)
##step3 Estimate 3UTR usage
res <- testUsage(CPsites=CPs, 
                 coverage=coverage, 
                 genome=BSgenome.Mmusculus.UCSC.mm10,
                 utr3=utr3.mm10, 
                 method="fisher.exact",
                 gp1="Baf3", gp2="UM15")

##step4 view the results
as(res, "GRanges") 

filterRes(res, gp1="Baf3", gp2="UM15",
          background_coverage_threshold=3,
          adj.P.Val_cutoff=0.05, 
          dPDUI_cutoff=0.3, 
          PDUI_logFC_cutoff=0.59)
```

The steps described above can be done in one function call.

```{r OneStep}
if(interactive()){
    res <- inPASWrapper(bedgraphs=bedgraphs, tags=c("Baf3", "UM15"), 
              genome=BSgenome.Mmusculus.UCSC.mm10, 
              utr3=utr3.mm10, gp1="Baf3", gp2="UM15",
              txdb=TxDb.Mmusculus.UCSC.mm10.knownGene,
              search_point_START=200,
              short_coverage_threshold=15,
              long_coverage_threshold=3, 
              cutStart=0, cutEnd=.2,
              removeScaffolds = TRUE,
              hugeData=FALSE,
              shift_range=50,
              PolyA_PWM=pwm, classifier=classifier,
              method="fisher.exact",
              adj.P.Val_cutoff=0.05,
              dPDUI_cutoff=0.3, 
              PDUI_logFC_cutoff=0.59)
}
```

InPAS can also handle single group data.

```{r SingleGroupData}
inPASWrapper(bedgraphs=bedgraphs[1], tags=c("Baf3"), 
      genome=BSgenome.Mmusculus.UCSC.mm10, 
      utr3= utr3.mm10, gp1="Baf3", gp2=NULL,
      txdb=TxDb.Mmusculus.UCSC.mm10.knownGene,
      search_point_START=200,
      short_coverage_threshold=15,
      long_coverage_threshold=3, 
      removeScaffolds = TRUE,
      cutStart=0, cutEnd=.2, 
      hugeData=FALSE, 
      PolyA_PWM=pwm, classifier=classifier,
      method="singleSample",
      adj.P.Val_cutoff=0.05,
      step=10)
```

# Session Info
```{r sessionInfo, results='asis'}
sessionInfo()
```
